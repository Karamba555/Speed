diff -ruN a/drivers/net/usb/qmi_wwan.c b/drivers/net/usb/qmi_wwan.c
--- a/drivers/net/usb/qmi_wwan.c	2024-10-07 13:58:42.249515000 +0200
+++ b/drivers/net/usb/qmi_wwan.c	2024-10-07 14:47:23.035556525 +0200
@@ -43,27 +43,111 @@
  *
  * These devices may alternatively/additionally be configured using AT
  * commands on a serial interface
+ *
+ * Modifications to merge latest driver and Atel bridge mode by 
+ * Assured Wireless.
  */
 
+// For bridge mode
+#include <linux/etherdevice.h>
+#include <net/arp.h>
+#include <net/ip.h>
+#include <net/ipv6.h>
+
+// NOTE: This disables the RAWIP/MUX handling in the modern driver
+#define QUECTEL_WWAN_QMAP 4
+#define PACKET_DEBUG 1
+
 /* driver specific data */
 struct qmi_wwan_state {
 	struct usb_driver *subdriver;
 	atomic_t pmcount;
-	unsigned long flags;
+#ifdef QUECTEL_WWAN_QMAP
+	unsigned long unused;
+#else
+	unsigned long old_flags;
+#endif
 	struct usb_interface *control;
 	struct usb_interface *data;
 };
 
+/* default ethernet address used by the modem */
+static const u8 default_modem_addr[ETH_ALEN] = {0x02, 0x50, 0xf3};
+
+/* Could be put in the QMI structure */
+static unsigned long qmi_flags = 0;
+
+
 enum qmi_wwan_flags {
 	QMI_WWAN_FLAG_RAWIP = 1 << 0,
 	QMI_WWAN_FLAG_MUX = 1 << 1,
 	QMI_WWAN_FLAG_PASS_THROUGH = 1 << 2,
+	QMI_WWAN_FLAG_BRIDGE_MAC_SET = 1 << 3,
 };
 
 enum qmi_wwan_quirks {
 	QMI_WWAN_QUIRK_DTR = 1 << 0,	/* needs "set DTR" request */
+    QMI_WWAN_QUIRK_RAW = 1 << 1,
+};
+
+#if defined(QUECTEL_WWAN_QMAP)
+#define QUECTEL_QMAP_MUX_ID 0x81
+
+static uint __read_mostly qmap_mode = 0;
+module_param( qmap_mode, uint, S_IRUGO);
+module_param_named( rx_qmap, qmap_mode, uint, S_IRUGO );
+#endif
+
+#ifndef CONFIG_BRIDGE
+#define CONFIG_BRIDGE
+#endif
+
+#if defined(CONFIG_BRIDGE) && defined(QUECTEL_WWAN_QMAP)
+#define QUECTEL_BRIDGE_MODE
+#endif
+
+#ifdef QUECTEL_BRIDGE_MODE
+static uint __read_mostly bridge_mode /*= BIT(0) | BIT(1)*/;
+module_param( bridge_mode, uint, S_IRUGO );
+#endif
+
+#if defined(QUECTEL_WWAN_QMAP)
+typedef struct sQmiWwanQmap
+{
+	struct usbnet *mpNetDev;
+	atomic_t refcount;
+	struct net_device *mpQmapNetDev[QUECTEL_WWAN_QMAP];
+	uint link_state;
+	uint qmap_mode;
+#ifdef QUECTEL_BRIDGE_MODE
+	uint bridge_mode;
+	uint bridge_ipv4;
+	unsigned char bridge_mac[ETH_ALEN];
+#endif
+} sQmiWwanQmap;
+
+
+struct qmap_priv {
+	struct net_device *real_dev;
+	u8 offset_id;
+#ifdef QUECTEL_BRIDGE_MODE
+	uint bridge_mode;
+	uint bridge_ipv4;
+	unsigned char bridge_mac[ETH_ALEN];
+#endif
 };
 
+struct qmap_hdr {
+    u8 cd_rsvd_pad;
+    u8 mux_id;
+    u16 pkt_len;
+} __packed;
+
+#ifdef QUECTEL_BRIDGE_MODE
+static int is_qmap_netdev(const struct net_device *netdev);
+#endif
+#endif
+
 struct qmimux_hdr {
 	u8 pad;
 	u8 mux_id;
@@ -73,8 +157,425 @@
 struct qmimux_priv {
 	struct net_device *real_dev;
 	u8 mux_id;
+	struct pcpu_sw_netstats __percpu *stats64;
 };
 
+#if defined(QUECTEL_WWAN_QMAP)
+#ifdef QUECTEL_BRIDGE_MODE
+
+static int bridge_arp_reply(struct net_device *net, struct sk_buff *skb, uint bridge_ipv4) {
+    struct arphdr *parp;
+    u8 *arpptr, *sha;
+    u8  sip[4], tip[4], ipv4[4];
+    struct sk_buff *reply = NULL;
+    u8 localip[4] = { 192, 168, 113, 1};
+	
+	//return 0;
+	
+	//pr_info("qmi: bridge_arp_reply");
+	
+    ipv4[0]  = (bridge_ipv4 >> 24) & 0xFF;
+    ipv4[1]  = (bridge_ipv4 >> 16) & 0xFF;
+    ipv4[2]  = (bridge_ipv4 >> 8) & 0xFF;
+    ipv4[3]  = (bridge_ipv4 >> 0) & 0xFF;
+        
+    parp = arp_hdr(skb);
+
+    if (parp->ar_hrd == htons(ARPHRD_ETHER)  && parp->ar_pro == htons(ETH_P_IP) &&
+        parp->ar_op  == htons(ARPOP_REQUEST) && parp->ar_hln == 6 && parp->ar_pln == 4) {
+		char *message;
+		
+        arpptr = (u8 *)parp + sizeof(struct arphdr);
+        sha = arpptr;
+        arpptr += net->addr_len;	/* sha */
+        memcpy(sip, arpptr, sizeof(sip));
+        arpptr += sizeof(sip);
+        arpptr += net->addr_len;	/* tha */
+        memcpy(tip, arpptr, sizeof(tip));
+
+        message = "";
+
+        if (tip[0] == ipv4[0] && tip[1] == ipv4[1] && (tip[2]&0xFC) == (ipv4[2]&0xFC) && tip[3] != ipv4[3]) {
+            // Query from LAN side of the gateway MAC
+            
+			message = "tip == ipv4, reply generated";
+            reply = arp_create(ARPOP_REPLY, ETH_P_ARP, *((__be32 *)sip), net, *((__be32 *)tip), sha, default_modem_addr, sha);
+            
+		} else if (sip[0] == localip[0] && sip[1] == localip[1] && sip[2] == localip[2] && sip[3] == localip[3]) {
+            // Query from EI for gateway MAC. This is perhaps never needed, since we create a static 
+            // ARP entry anyway
+			message = "sip == localip, reply generated";
+			reply = arp_create(ARPOP_REPLY, ETH_P_ARP, *((__be32 *)sip), net, *((__be32 *)tip), sha, default_modem_addr, sha);
+            
+            // Other cases shoud only happen if the routing rules are wrong.  But we probably don't want these, since
+            // They end up creating EI arp entries. 
+            
+/*        } else if (sip[0] == ipv4[0] && sip[1] == ipv4[1] && sip[2] == ipv4[2] && sip[3] == ipv4[3]) {
+ *          /
+ * 
+			message = "sip == ipv4, reply generated"; 
+            reply = arp_create(ARPOP_REPLY, ETH_P_ARP, *((__be32 *)sip), net, *((__be32 *)tip), sha, default_modem_addr, sha);*/
+            
+	    } else {
+			message = "No match, no reply";
+		}
+
+#if PACKET_DEBUG
+		pr_info("qmi: bridge_arp_reply: %s sip=%d.%d.%d.%d, tip=%d.%d.%d.%d, ipv4=%d.%d.%d.%d - %s\n", 
+			netdev_name(net),
+            sip[0], sip[1], sip[2], sip[3], 
+		    tip[0], tip[1], tip[2], tip[3], 
+		    ipv4[0], ipv4[1], ipv4[2], ipv4[3],
+		    message
+   			);
+#endif		
+    
+
+        if (reply) {
+            skb_reset_mac_header(reply);
+            __skb_pull(reply, skb_network_offset(reply));
+            reply->ip_summed = CHECKSUM_UNNECESSARY;
+            reply->pkt_type = PACKET_HOST;
+
+            netif_rx_ni(reply);
+            return 1;
+        } 
+        return 0;
+    }
+
+#if PACKET_DEBUG
+	pr_info("qmi: no ARP generated");
+#endif    
+
+    return 0;
+}
+
+
+static struct sk_buff *bridge_mode_tx_fixup(struct net_device *net, struct sk_buff *skb, uint bridge_ipv4, unsigned char *bridge_mac) {
+	struct ethhdr *ehdr;
+	const struct iphdr *iph;
+	
+	skb_reset_mac_header(skb);
+	ehdr = eth_hdr(skb);	
+	
+
+	if (ehdr->h_proto == htons(ETH_P_ARP)) {
+		if (bridge_ipv4)
+			bridge_arp_reply(net, skb, bridge_ipv4);
+		//pr_info("qmi: Do ARP");
+		return NULL;
+	}
+
+#if 0
+	pr_info("%s bridge_mode_tx_fixup: proto: %04x:%04x dest mac: %02x:%02x:%02x:%02x:%02x:%02x\n", 
+				netdev_name(net), 
+				htons(ETH_P_ARP), ehdr->h_proto,
+				ehdr->h_dest[0], ehdr->h_dest[1], ehdr->h_dest[2], ehdr->h_dest[3], ehdr->h_dest[4], ehdr->h_dest[5]); 
+				//bridge_mac[0], bridge_mac[1], bridge_mac[2], bridge_mac[3], bridge_mac[4], bridge_mac[5]);
+#endif
+	
+	iph = ip_hdr(skb);
+	//DBG("tx_fixup iphdr: ");
+	//PrintHex((void *)iph, sizeof(struct iphdr));
+	
+
+
+    // DHCP request allows us to infer the LAN side MAC. 
+	if (ehdr->h_proto == htons(ETH_P_IP) && iph->protocol == IPPROTO_UDP && 
+        ((iph->saddr == 0x00000000) || (ntohl(iph->saddr) == bridge_ipv4)) &&  // Source might be unset, or it might come from already set allocated IP address 
+        iph->daddr == 0xFFFFFFFF) {
+		//if (udp_hdr(skb)->dest == htons(67)) //DHCP Request
+		if (memcmp(bridge_mac, ehdr->h_source, ETH_ALEN))
+		{
+			memcpy(bridge_mac, ehdr->h_source, ETH_ALEN);
+            
+            qmi_flags |= QMI_WWAN_FLAG_BRIDGE_MAC_SET;
+            
+            //priv->bridge_mac_set = true;
+			pr_info("qmi_wwan: %s LAN MAC Address: %02x:%02x:%02x:%02x:%02x:%02x" /* Dest: %02x:%02x:%02x:%02x:%02x:%02x\n"*/, netdev_name(net),
+				bridge_mac[0], bridge_mac[1], bridge_mac[2], bridge_mac[3], bridge_mac[4], bridge_mac[5] //,
+//				ehdr->h_dest[0], ehdr->h_dest[1], ehdr->h_dest[2], ehdr->h_dest[3], ehdr->h_dest[4], ehdr->h_dest[5]
+   				);
+            //return skb;
+		} else {
+          // DHCP from bridge MAC we've already seen   
+          //pr_info("qmi_wwan: DHCP from LAN host already known");
+        }
+		return skb;
+	}
+	
+	// If bridge_mac isn't set yet, then could just discard. 
+    
+    if (unlikely(!(qmi_flags & QMI_WWAN_FLAG_BRIDGE_MAC_SET))) {
+#if PACKET_DEBUG
+      //pr_info("Bridge MAC not set yet - outgoing packet discarded");
+#endif      
+      
+      return NULL;
+        
+    } else if (memcmp(ehdr->h_source, bridge_mac, ETH_ALEN)) {
+//pr_info("tx_fixup 1");
+		if (!memcmp(ehdr->h_source, ehdr->h_dest, ETH_ALEN)) {
+#if PACKET_DEBUG
+			pr_info("Source and dest match - non bridge MAC, discarded: %02x:%02x:%02x:%02x:%02x:%02x",
+				ehdr->h_source[0],
+				ehdr->h_source[1],
+				ehdr->h_source[2],
+				ehdr->h_source[3],
+				ehdr->h_source[4],
+				ehdr->h_source[5]);
+#endif			
+        
+		/*	pr_info("Source and dest fixed up - from: %02x:%02x:%02x:%02x:%02x:%02x to: %02x:%02x:%02x:%02x:%02x:%02x",
+				ehdr->h_source[0],
+				ehdr->h_source[1],
+				ehdr->h_source[2],
+				ehdr->h_source[3],
+				ehdr->h_source[4],
+				ehdr->h_source[5],
+				bridge_mac[0], 
+				bridge_mac[1], 
+				bridge_mac[2], 
+				bridge_mac[3], 
+				bridge_mac[4], 
+				bridge_mac[5]
+			);
+			// Fixup for packets generated locally
+			memcpy(ehdr->h_source, bridge_mac, ETH_ALEN);
+			memset(ehdr->h_dest, 0xff, ETH_ALEN);*/
+			return NULL;
+			//return skb;
+			
+		} else {
+//pr_info("tx_fixup 2");
+#if PACKET_DEBUG
+			pr_info("tx_fixup - Source is not bridge mac: %02x:%02x:%02x:%02x:%02x:%02x (sip=%08x) - discarded",
+				ehdr->h_source[0],
+				ehdr->h_source[1],
+				ehdr->h_source[2],
+				ehdr->h_source[3],
+				ehdr->h_source[4],
+				ehdr->h_source[5],
+                ntohl(iph->saddr)
+			);
+#endif
+		}
+			
+		return NULL;
+	}
+	if ((ehdr->h_dest[0] == 0xff) && (ehdr->h_dest[1] == 0xff) && (ehdr->h_dest[2] == 0xff) &&
+		(ehdr->h_dest[3] == 0xff) && (ehdr->h_dest[4] == 0xff) && (ehdr->h_dest[5] == 0xff)) {
+#if PACKET_DEBUG
+		pr_info("tx_fixup - Destination MAC not set Source:  %02x:%02x:%02x:%02x:%02x:%02x Proto: %d sip=%08x, tip=%08x (bip=%08x)", 
+			ehdr->h_source[0],
+			ehdr->h_source[1],
+			ehdr->h_source[2],
+			ehdr->h_source[3],
+			ehdr->h_source[4],
+			ehdr->h_source[5],
+			iph->protocol,
+			ntohl(iph->saddr),
+			ntohl(iph->daddr),
+			bridge_ipv4); 
+#endif
+		return NULL;
+	}
+
+	return skb;
+}
+
+static ssize_t qmap_mode_show(struct device *dev, struct device_attribute *attr, char *buf) {
+	struct net_device *netdev = to_net_dev(dev);
+	struct usbnet * usbnetdev = netdev_priv( netdev );
+	struct qmi_wwan_state *info = (void *)&usbnetdev->data;
+	sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+
+	return snprintf(buf, PAGE_SIZE, "%d\n",  pQmapDev->qmap_mode);
+}
+
+static ssize_t qmap_mode_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count) {
+	struct net_device *netdev = to_net_dev(dev);
+    struct usbnet * usbnetdev = netdev_priv( netdev );
+    struct qmi_wwan_state *info = (void *)&usbnetdev->data;    
+    sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+    
+    pQmapDev->qmap_mode = simple_strtoul(buf, NULL, 16);
+
+	return count;
+}
+
+static DEVICE_ATTR(qmap_mode, S_IWUSR | S_IRUGO, qmap_mode_show, qmap_mode_store);
+
+static ssize_t link_state_show(struct device *dev, struct device_attribute *attr, char *buf) {
+	struct net_device *netdev = to_net_dev(dev);
+	struct usbnet * usbnetdev = netdev_priv( netdev );
+	struct qmi_wwan_state *info = (void *)&usbnetdev->data;
+	sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+
+	return snprintf(buf, PAGE_SIZE, "0x%x\n",  pQmapDev->link_state);
+}
+
+static ssize_t link_state_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count) {
+	struct net_device *netdev = to_net_dev(dev);
+	struct usbnet * usbnetdev = netdev_priv( netdev );
+	struct qmi_wwan_state *info = (void *)&usbnetdev->data;
+	sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+	unsigned link_state = 0;
+	unsigned old_link = pQmapDev->link_state;
+
+	link_state = simple_strtoul(buf, NULL, 0);
+	if (pQmapDev->qmap_mode == 1)
+		pQmapDev->link_state = !!link_state;
+	else if (pQmapDev->qmap_mode > 1) {
+		if (0 < link_state && link_state <= pQmapDev->qmap_mode)
+			pQmapDev->link_state |= (1 << (link_state - 1));
+		else if (0x80 < link_state && link_state <= (0x80 + pQmapDev->qmap_mode))
+			pQmapDev->link_state &= ~(1 << ((link_state&0xF) - 1));
+	}
+
+	if (old_link != pQmapDev->link_state)
+		dev_info(dev, "link_state 0x%x -> 0x%x (qmap mode = %d)\n", old_link, 
+                 pQmapDev->link_state, pQmapDev->qmap_mode);
+
+	return count;
+}
+
+static ssize_t bridge_mode_show(struct device *dev, struct device_attribute *attr, char *buf) {
+	struct net_device *netdev = to_net_dev(dev);
+	uint bridge_mode = 0;
+    
+	if (is_qmap_netdev(netdev)) {
+		struct qmap_priv *priv = netdev_priv(netdev);
+		bridge_mode = priv->bridge_mode;	
+	}
+	else {
+		struct usbnet * usbnetdev = netdev_priv( netdev );
+		struct qmi_wwan_state *info = (void *)&usbnetdev->data;
+		sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+		bridge_mode = pQmapDev->bridge_mode;
+	}
+
+	return snprintf(buf, PAGE_SIZE, "%u\n", bridge_mode);
+}
+
+static ssize_t bridge_ipv4_show(struct device *dev, struct device_attribute *attr, char *buf) {
+	struct net_device *netdev = to_net_dev(dev);
+	unsigned int bridge_ipv4 = 0;
+	unsigned char ipv4[4];
+
+	if (is_qmap_netdev(netdev)) {
+		struct qmap_priv *priv = netdev_priv(netdev);
+		bridge_ipv4 = priv->bridge_ipv4;	
+	}
+	else {
+		struct usbnet * usbnetdev = netdev_priv( netdev );
+		struct qmi_wwan_state *info = (void *)&usbnetdev->data;
+		sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+		bridge_ipv4 = pQmapDev->bridge_ipv4;	
+	}
+
+	ipv4[0]  = (bridge_ipv4 >> 24) & 0xFF;
+	ipv4[1]  = (bridge_ipv4 >> 16) & 0xFF;
+	ipv4[2]  = (bridge_ipv4 >> 8) & 0xFF;
+	ipv4[3]  = (bridge_ipv4 >> 0) & 0xFF;
+    
+	return snprintf(buf, PAGE_SIZE, "%d.%d.%d.%d\n",  ipv4[0], ipv4[1], ipv4[2], ipv4[3]);
+}
+
+static ssize_t bridge_ipv4_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count) {
+	struct net_device *netdev = to_net_dev(dev);
+
+	if (is_qmap_netdev(netdev)) {
+		struct qmap_priv *priv = netdev_priv(netdev);
+		priv->bridge_ipv4 = simple_strtoul(buf, NULL, 16);
+	}
+	else {
+		struct usbnet * usbnetdev = netdev_priv( netdev );
+		struct qmi_wwan_state *info = (void *)&usbnetdev->data;
+		sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+		pQmapDev->bridge_ipv4 = simple_strtoul(buf, NULL, 16);
+	}
+
+	return count;
+}
+
+static ssize_t bridge_mac_show(struct device *dev, struct device_attribute *attr, char *buf) {
+	struct net_device *netdev = to_net_dev(dev);
+    unsigned char *bridge_mac;	
+	
+	if (is_qmap_netdev(netdev)) {
+		struct qmap_priv *priv = netdev_priv(netdev);
+		bridge_mac = priv->bridge_mac;	
+	}
+	else {
+		struct usbnet * usbnetdev = netdev_priv( netdev );
+		struct qmi_wwan_state *info = (void *)&usbnetdev->data;
+		sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+		bridge_mac = pQmapDev->bridge_mac;	
+	}
+
+	return snprintf(buf, PAGE_SIZE, "%02x:%02x:%02x:%02x:%02x:%02x\n", 
+					bridge_mac[0], bridge_mac[1], bridge_mac[2], bridge_mac[3], bridge_mac[4], bridge_mac[5]);
+}
+
+
+static ssize_t bridge_mac_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count) {
+    unsigned char mac[6];
+    bool set = false;
+    size_t byte;
+    struct net_device *netdev = to_net_dev(dev);
+    
+    if (count < 17) return -1;
+    
+    for (byte = 0; byte < sizeof(mac); byte++) {
+       char hex[3] = { buf[byte * 3], buf[byte * 3 + 1], '\0' };
+       
+       if ((mac[byte] = simple_strtoul(hex, NULL, 16))) set = true;   
+    }
+    
+    if (set) {
+       qmi_flags |= QMI_WWAN_FLAG_BRIDGE_MAC_SET;   
+       pr_info("qmi_wwan: Bridge MAC set to: %02x:%02x:%02x:%02x:%02x:%02x",
+               mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+    } else {
+       qmi_flags &= ~QMI_WWAN_FLAG_BRIDGE_MAC_SET;
+       pr_info("qmi_wwan: Bridge MAC cleared");
+    }
+    
+	if (is_qmap_netdev(netdev)) {
+		struct qmap_priv *priv = netdev_priv(netdev);
+        
+        memcpy(priv->bridge_mac, mac, sizeof(mac));
+	}
+	else {
+		struct usbnet * usbnetdev = netdev_priv( netdev );
+		struct qmi_wwan_state *info = (void *)&usbnetdev->data;
+		sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+
+        memcpy(pQmapDev->bridge_mac, mac, sizeof(mac));       
+	}
+	return count;
+}
+
+static ssize_t bridge_mode_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count) {
+	struct net_device *netdev = to_net_dev(dev);
+
+	if (is_qmap_netdev(netdev)) {
+		struct qmap_priv *priv = netdev_priv(netdev);
+		priv->bridge_mode = simple_strtoul(buf, NULL, 16);
+	}
+	else {
+		struct usbnet * usbnetdev = netdev_priv( netdev );
+		struct qmi_wwan_state *info = (void *)&usbnetdev->data;
+		sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+		pQmapDev->bridge_mode = simple_strtoul(buf, NULL, 16);
+	}
+
+	return count;
+}
+#endif
+#endif
+
 static int qmimux_open(struct net_device *dev)
 {
 	struct qmimux_priv *priv = netdev_priv(dev);
@@ -307,9 +808,9 @@
 static void qmi_wwan_netdev_setup(struct net_device *net)
 {
 	struct usbnet *dev = netdev_priv(net);
-	struct qmi_wwan_state *info = (void *)&dev->data;
+	//struct qmi_wwan_state *info = (void *)&dev->data;
 
-	if (info->flags & QMI_WWAN_FLAG_RAWIP) {
+	if (/*info->flags*/ qmi_flags & QMI_WWAN_FLAG_RAWIP) {
 		net->header_ops      = NULL;  /* No header */
 		net->type            = ARPHRD_NONE;
 		net->hard_header_len = 0;
@@ -332,39 +833,34 @@
 
 static ssize_t raw_ip_show(struct device *d, struct device_attribute *attr, char *buf)
 {
-	struct usbnet *dev = netdev_priv(to_net_dev(d));
-	struct qmi_wwan_state *info = (void *)&dev->data;
+//	struct usbnet *dev = netdev_priv(to_net_dev(d));
+//	struct qmi_wwan_state *info = (void *)&dev->data;
 
-	return sprintf(buf, "%c\n", info->flags & QMI_WWAN_FLAG_RAWIP ? 'Y' : 'N');
+	return sprintf(buf, "%c\n", /*info->flags*/ qmi_flags & QMI_WWAN_FLAG_RAWIP ? 'Y' : 'N');
 }
 
-static ssize_t raw_ip_store(struct device *d,  struct device_attribute *attr, const char *buf, size_t len)
+static ssize_t raw_ip_store(struct device *d, struct device_attribute *attr, const char *buf, size_t len)
 {
 	struct usbnet *dev = netdev_priv(to_net_dev(d));
-	struct qmi_wwan_state *info = (void *)&dev->data;
+//	struct qmi_wwan_state *info = (void *)&dev->data;
 	bool enable;
 	int ret;
 
 	if (strtobool(buf, &enable))
 		return -EINVAL;
 
+//    netdev_err(dev->net, "raw_ip_store: %s %02x", buf, (unsigned int)(qmi_flags & QMI_WWAN_FLAG_RAWIP));
+    
 	/* no change? */
-	if (enable == (info->flags & QMI_WWAN_FLAG_RAWIP))
+	if (enable == (/*info->flags*/ qmi_flags & QMI_WWAN_FLAG_RAWIP))
 		return len;
 
-	/* ip mode cannot be cleared when pass through mode is set */
-	if (!enable && (info->flags & QMI_WWAN_FLAG_PASS_THROUGH)) {
-		netdev_err(dev->net,
-			   "Cannot clear ip mode on pass through device\n");
-		return -EINVAL;
-	}
-
 	if (!rtnl_trylock())
 		return restart_syscall();
 
 	/* we don't want to modify a running netdev */
 	if (netif_running(dev->net)) {
-		netdev_err(dev->net, "Cannot change a running device\n");
+		netdev_err(dev->net, "Cannot change a running device (raw_ip)\n");
 		ret = -EBUSY;
 		goto err;
 	}
@@ -378,9 +874,9 @@
 	}
 
 	if (enable)
-		info->flags |= QMI_WWAN_FLAG_RAWIP;
+		/*info->flags*/ qmi_flags |= QMI_WWAN_FLAG_RAWIP;
 	else
-		info->flags &= ~QMI_WWAN_FLAG_RAWIP;
+		/*info->flags*/ qmi_flags &= ~QMI_WWAN_FLAG_RAWIP;
 	qmi_wwan_netdev_setup(dev->net);
 	call_netdevice_notifiers(NETDEV_POST_TYPE_CHANGE, dev->net);
 	ret = len;
@@ -410,7 +906,7 @@
 static ssize_t add_mux_store(struct device *d,  struct device_attribute *attr, const char *buf, size_t len)
 {
 	struct usbnet *dev = netdev_priv(to_net_dev(d));
-	struct qmi_wwan_state *info = (void *)&dev->data;
+//	struct qmi_wwan_state *info = (void *)&dev->data;
 	u8 mux_id;
 	int ret;
 
@@ -429,10 +925,19 @@
 		ret = -EINVAL;
 		goto err;
 	}
+	
+	 netdev_dbg(dev->net, "mux_store: %d %02x", mux_id, (unsigned int)(qmi_flags & QMI_WWAN_FLAG_MUX));
+	
+    /* we don't want to modify a running netdev */
+	if (netif_running(dev->net)) {
+		netdev_err(dev->net, "Cannot change a running device (add_mux)\n");
+		ret = -EBUSY;
+		goto err;
+	}
 
 	ret = qmimux_register_device(dev->net, mux_id);
 	if (!ret) {
-		info->flags |= QMI_WWAN_FLAG_MUX;
+		/*info->flags*/ qmi_flags |= QMI_WWAN_FLAG_MUX;
 		ret = len;
 	}
 err:
@@ -448,7 +953,7 @@
 static ssize_t del_mux_store(struct device *d,  struct device_attribute *attr, const char *buf, size_t len)
 {
 	struct usbnet *dev = netdev_priv(to_net_dev(d));
-	struct qmi_wwan_state *info = (void *)&dev->data;
+//	struct qmi_wwan_state *info = (void *)&dev->data;
 	struct net_device *del_dev;
 	u8 mux_id;
 	int ret = 0;
@@ -468,78 +973,247 @@
 	qmimux_unregister_device(del_dev, NULL);
 
 	if (!qmimux_has_slaves(dev))
-		info->flags &= ~QMI_WWAN_FLAG_MUX;
+		/*info->flags*/ qmi_flags &= ~QMI_WWAN_FLAG_MUX;
 	ret = len;
 err:
 	rtnl_unlock();
 	return ret;
 }
 
-static ssize_t pass_through_show(struct device *d,
-				 struct device_attribute *attr, char *buf)
+static DEVICE_ATTR_RW(raw_ip);
+static DEVICE_ATTR_RW(add_mux);
+static DEVICE_ATTR_RW(del_mux);
+
+#if defined(QUECTEL_WWAN_QMAP)
+static DEVICE_ATTR(link_state, S_IWUSR | S_IRUGO, link_state_show, link_state_store);
+#ifdef QUECTEL_BRIDGE_MODE
+static DEVICE_ATTR(bridge_mode, S_IWUSR | S_IRUGO, bridge_mode_show, bridge_mode_store);
+static DEVICE_ATTR(bridge_ipv4, S_IWUSR | S_IRUGO, bridge_ipv4_show, bridge_ipv4_store);
+static DEVICE_ATTR(bridge_mac,  S_IWUSR | S_IRUGO, bridge_mac_show,  bridge_mac_store);
+#endif
+#endif
+
+static struct attribute *qmi_wwan_sysfs_attrs[] = {
+	&dev_attr_raw_ip.attr,
+	&dev_attr_add_mux.attr,
+	&dev_attr_del_mux.attr,
+#if defined(QUECTEL_WWAN_QMAP)
+    &dev_attr_link_state.attr,
+	&dev_attr_qmap_mode.attr,
+#ifdef QUECTEL_BRIDGE_MODE
+	&dev_attr_bridge_mode.attr,
+	&dev_attr_bridge_ipv4.attr,
+	&dev_attr_bridge_mac.attr,
+#endif
+#endif
+	NULL,
+};
+
+static struct attribute_group qmi_wwan_sysfs_attr_group = {
+	.name = "qmi",
+	.attrs = qmi_wwan_sysfs_attrs,
+};
+
+#if defined(QUECTEL_WWAN_QMAP)
+#ifdef QUECTEL_BRIDGE_MODE
+static struct attribute *qmi_qmap_sysfs_attrs[] = {
+	&dev_attr_bridge_mode.attr,
+	&dev_attr_bridge_ipv4.attr,
+	&dev_attr_bridge_mac.attr,
+	NULL,
+};
+
+static struct attribute_group qmi_qmap_sysfs_attr_group = {
+	.attrs = qmi_qmap_sysfs_attrs,
+};
+#endif
+
+static int qmap_open(struct net_device *dev)
 {
-	struct usbnet *dev = netdev_priv(to_net_dev(d));
-	struct qmi_wwan_state *info;
+	struct qmap_priv *priv = netdev_priv(dev);
+	struct net_device *real_dev = priv->real_dev;
 
-	info = (void *)&dev->data;
-	return sprintf(buf, "%c\n",
-		       info->flags & QMI_WWAN_FLAG_PASS_THROUGH ? 'Y' : 'N');
+//	pr_info("qmi: qmap_open");
+	
+	if (!(priv->real_dev->flags & IFF_UP))
+		return -ENETDOWN;
+
+	if (netif_carrier_ok(real_dev))
+		netif_carrier_on(dev);
+	return 0;
 }
 
-static ssize_t pass_through_store(struct device *d,
-				  struct device_attribute *attr,
-				  const char *buf, size_t len)
+static int qmap_stop(struct net_device *pNet)
 {
-	struct usbnet *dev = netdev_priv(to_net_dev(d));
-	struct qmi_wwan_state *info;
-	bool enable;
+	//pr_info("qmi: qmap_close");
+	
+	netif_carrier_off(pNet);
+	return 0;
+}
 
-	if (strtobool(buf, &enable))
-		return -EINVAL;
+static int qmap_start_xmit(struct sk_buff *skb, struct net_device *pNet)
+{
+	int err;
+	struct qmap_priv *priv = netdev_priv(pNet);
+	unsigned int len;
+	struct qmap_hdr *hdr;
 
-	info = (void *)&dev->data;
+	//pr_info("qmap_start_xmit");
+	
+	skb_reset_mac_header(skb);
 
-	/* no change? */
-	if (enable == (info->flags & QMI_WWAN_FLAG_PASS_THROUGH))
-		return len;
+#ifdef QUECTEL_BRIDGE_MODE
+	if (priv->bridge_mode && bridge_mode_tx_fixup(pNet, skb, priv->bridge_ipv4, priv->bridge_mac) == NULL) {
+		  //pr_info("tx returns NULL");
+	      dev_kfree_skb_any (skb);
+	      return NETDEV_TX_OK;
+	}
+#endif
+
+	if (skb_pull(skb, ETH_HLEN) == NULL) {
+		  //pr_info("skb_pull returns NULL");
+	      dev_kfree_skb_any (skb);
+	      return NETDEV_TX_OK;
+   	}
+   
+	len = skb->len;
+	hdr = (struct qmap_hdr *)skb_push(skb, sizeof(struct qmap_hdr));
+	hdr->cd_rsvd_pad = 0;
+	hdr->mux_id = QUECTEL_QMAP_MUX_ID + priv->offset_id;
+	hdr->pkt_len = cpu_to_be16(len);
 
-	/* pass through mode can be set for raw ip devices only */
-	if (!(info->flags & QMI_WWAN_FLAG_RAWIP)) {
-		netdev_err(dev->net,
-			   "Cannot set pass through mode on non ip device\n");
-		return -EINVAL;
+	skb->dev = priv->real_dev;
+	err = dev_queue_xmit(skb);
+	if (err == NET_XMIT_SUCCESS) {
+		//pr_info("qmap_start_xmit success");
+		pNet->stats.tx_packets++;
+		pNet->stats.tx_bytes += skb->len;
+	} else {
+		//pr_info("xmi returns failure");
+		pNet->stats.tx_errors++;
 	}
 
-	if (enable)
-		info->flags |= QMI_WWAN_FLAG_PASS_THROUGH;
-	else
-		info->flags &= ~QMI_WWAN_FLAG_PASS_THROUGH;
+	return err;
+}
+
+static const struct net_device_ops qmap_netdev_ops = {
+	.ndo_open       = qmap_open,
+	.ndo_stop       = qmap_stop,
+	.ndo_start_xmit = qmap_start_xmit,
+};
 
-	return len;
+
+static int qmap_register_device(sQmiWwanQmap * pDev, u8 offset_id)
+{
+    struct net_device *real_dev = pDev->mpNetDev->net;
+    struct net_device *qmap_net;
+    struct qmap_priv *priv;
+    int err;
+
+	pr_info("qmi: qmap_register_device");
+	
+    qmap_net = alloc_etherdev(sizeof(*priv));
+    if (!qmap_net)
+        return -ENOBUFS;
+
+    SET_NETDEV_DEV(qmap_net, &real_dev->dev);
+    priv = netdev_priv(qmap_net);
+    priv->offset_id = offset_id;
+    priv->real_dev = real_dev;
+    sprintf(qmap_net->name, "%s.%d", real_dev->name, offset_id + 1);
+    qmap_net->netdev_ops = &qmap_netdev_ops;
+    memcpy (qmap_net->dev_addr, real_dev->dev_addr, ETH_ALEN);
+
+#ifdef QUECTEL_BRIDGE_MODE
+	priv->bridge_mode = !!(pDev->bridge_mode & BIT(offset_id));
+	qmap_net->sysfs_groups[0] = &qmi_qmap_sysfs_attr_group;
+#endif
+
+    err = register_netdev(qmap_net);
+    if (err < 0)
+        goto out_free_newdev;
+    netif_device_attach (qmap_net);
+
+    pDev->mpQmapNetDev[offset_id] = qmap_net;
+    qmap_net->flags |= IFF_NOARP;
+
+    dev_info(&real_dev->dev, "%s %s\n", __func__, qmap_net->name);
+
+    return 0;
+
+out_free_newdev:
+    free_netdev(qmap_net);
+    return err;
 }
 
-static DEVICE_ATTR_RW(raw_ip);
-static DEVICE_ATTR_RW(add_mux);
-static DEVICE_ATTR_RW(del_mux);
-static DEVICE_ATTR_RW(pass_through);
 
-static struct attribute *qmi_wwan_sysfs_attrs[] = {
-	&dev_attr_raw_ip.attr,
-	&dev_attr_add_mux.attr,
-	&dev_attr_del_mux.attr,
-	&dev_attr_pass_through.attr,
-	NULL,
-};
 
-static struct attribute_group qmi_wwan_sysfs_attr_group = {
-	.name = "qmi",
-	.attrs = qmi_wwan_sysfs_attrs,
-};
+static void qmap_unregister_device(sQmiWwanQmap * pDev, u8 offset_id) {
+    struct net_device *net = pDev->mpQmapNetDev[offset_id];
+	
+	//pr_info("qmap_unregister_device");
+	
+    if (net != NULL) {
+        netif_carrier_off( net );
+        unregister_netdev (net);
+        free_netdev(net);
+    }
+}
 
-/* default ethernet address used by the modem */
-static const u8 default_modem_addr[ETH_ALEN] = {0x02, 0x50, 0xf3};
+#endif
+
+
+#ifdef QUECTEL_WWAN_QMAP
+
+#ifdef QUECTEL_BRIDGE_MODE
+static int is_qmap_netdev(const struct net_device *netdev) {
+	return netdev->netdev_ops == &qmap_netdev_ops;
+}
+#endif
 
-static const u8 buggy_fw_addr[ETH_ALEN] = {0x00, 0xa0, 0xc6, 0x00, 0x00, 0x00};
+
+static struct sk_buff *qmi_wwan_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags) {
+	
+	//pr_info("qmi_wwan_tx_fixup");
+	
+	//MDM9x07,MDM9628,MDM9x40,SDX20,SDX24 only work on RAW IP mode
+	if ((dev->driver_info->flags & FLAG_NOARP) == 0) {
+		//pr_info("noarp");
+		return skb;
+	}
+
+	// Skip Ethernet header from message
+	if (dev->net->hard_header_len == 0) {
+		//pr_info("no header");
+		return skb;
+	} else {
+		skb_reset_mac_header(skb);
+	}
+
+#ifdef QUECTEL_BRIDGE_MODE
+{
+	struct qmi_wwan_state *info = (void *)&dev->data;
+	sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+
+	if (pQmapDev->bridge_mode && bridge_mode_tx_fixup(dev->net, skb, pQmapDev->bridge_ipv4, pQmapDev->bridge_mac) == NULL) {
+	      dev_kfree_skb_any (skb);
+	      return NULL;
+	}
+}
+#endif
+
+	if (skb_pull(skb, ETH_HLEN)) {
+		return skb;
+	} else {
+		dev_err(&dev->intf->dev,  "Packet Dropped ");
+	}
+
+	// Filter the packet out, release it
+	//pr_info("Release");
+	dev_kfree_skb_any(skb);
+	return NULL;
+}
+#endif
 
 /* Make up an ethernet header if the packet doesn't have one.
  *
@@ -563,22 +1237,22 @@
  */
 static int qmi_wwan_rx_fixup(struct usbnet *dev, struct sk_buff *skb)
 {
-	struct qmi_wwan_state *info = (void *)&dev->data;
-	bool rawip = info->flags & QMI_WWAN_FLAG_RAWIP;
 	__be16 proto;
+	struct qmi_wwan_state *info = (void *)&dev->data;	
+#ifdef QUECTEL_BRIDGE_MODE
+	sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+#endif
+    bool rawip = /*info->*/qmi_flags & QMI_WWAN_FLAG_RAWIP;
 
+//	pr_info("qmi_wwan_rx_fixup: %d", rawip);
+	
 	/* This check is no longer done by usbnet */
 	if (skb->len < dev->net->hard_header_len)
 		return 0;
 
-	if (info->flags & QMI_WWAN_FLAG_MUX)
+    if (/*info->*/qmi_flags & QMI_WWAN_FLAG_MUX)
 		return qmimux_rx_fixup(dev, skb);
 
-	if (info->flags & QMI_WWAN_FLAG_PASS_THROUGH) {
-		skb->protocol = htons(ETH_P_MAP);
-		return 1;
-	}
-
 	switch (skb->data[0] & 0xf0) {
 	case 0x40:
 		proto = htons(ETH_P_IP);
@@ -600,24 +1274,232 @@
 		/* pass along other packets without modifications */
 		return 1;
 	}
-	if (rawip) {
+    if (rawip) {
 		skb_reset_mac_header(skb);
 		skb->dev = dev->net; /* normally set by eth_type_trans */
 		skb->protocol = proto;
 		return 1;
 	}
-
+	
 	if (skb_headroom(skb) < ETH_HLEN)
 		return 0;
 	skb_push(skb, ETH_HLEN);
 	skb_reset_mac_header(skb);
 	eth_hdr(skb)->h_proto = proto;
-	eth_zero_addr(eth_hdr(skb)->h_source);
+    eth_zero_addr(eth_hdr(skb)->h_source);
+#if 1 //Added by Quectel
+	// some kernels will drop ethernet packet whose souce mac is all zero
+	memcpy(eth_hdr(skb)->h_source, default_modem_addr, ETH_ALEN);
+#endif
+#ifdef QUECTEL_BRIDGE_MODE	
+	if (pQmapDev->bridge_mode) {
+		//pr_info("bridge_mode - fix up destination MAC");
+		memcpy(eth_hdr(skb)->h_dest, pQmapDev->bridge_mac, ETH_ALEN);
+		return 1;
+	}
+#endif
+
 fix_dest:
+//    pr_info("non bridge - fix_dest");
 	memcpy(eth_hdr(skb)->h_dest, dev->net->dev_addr, ETH_ALEN);
 	return 1;
 }
 
+#if defined(QUECTEL_WWAN_QMAP)
+static struct sk_buff *qmap_qmi_wwan_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags) {
+	struct qmi_wwan_state *info = (void *)&dev->data;
+	sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+	struct qmap_hdr *qhdr;
+
+//	pr_info("qmap_qmi_wwan_tx_fixup");
+	
+	if (unlikely(pQmapDev == NULL)) {
+		//pr_info("no qMapDev");
+		goto drop_skb;
+	} else if (unlikely(pQmapDev->qmap_mode && !pQmapDev->link_state)) {
+		dev_dbg(&dev->net->dev, "link_state 0x%x, drop skb, len = %u\n", pQmapDev->link_state, skb->len);
+		//pr_info("no link_state");
+		goto drop_skb;
+	} else if (pQmapDev->qmap_mode == 0) {
+		return qmi_wwan_tx_fixup(dev, skb, flags);
+	}
+	else if (pQmapDev->qmap_mode > 1) {
+		qhdr = (struct qmap_hdr *)skb->data;
+		if (qhdr->cd_rsvd_pad != 0) {
+			//pr_info("has pad");
+			goto drop_skb;
+		}
+		if ((qhdr->mux_id & 0xF0) != 0x80) {
+			//pr_info("mux_id: %02x\n", qhdr->mux_id);
+			goto drop_skb;
+		}
+		return skb;
+	}
+	else {
+		if (qmi_wwan_tx_fixup(dev, skb, flags)) {
+			qhdr = (struct qmap_hdr *)skb_push(skb, sizeof(struct qmap_hdr));
+			qhdr->cd_rsvd_pad = 0;
+			qhdr->mux_id = QUECTEL_QMAP_MUX_ID;
+			qhdr->pkt_len = cpu_to_be16(skb->len - sizeof(struct qmap_hdr));
+
+			//pr_info("return skb");
+                    return skb;
+		}
+		else {
+			//pr_info("return null");
+			return NULL;
+		}
+	}
+
+drop_skb:
+//    pr_info("drop_skb");
+	dev_kfree_skb_any (skb);
+	return NULL;
+}
+
+static int qmap_qmi_wwan_rx_fixup(struct usbnet *dev, struct sk_buff *skb)
+{
+	struct qmi_wwan_state *info = (void *)&dev->data;
+	sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+	static int debug_len = 0;
+	int debug_pkts = 0;
+	int update_len = skb->len;
+
+    dev_dbg(&dev->intf->dev, "qmap_qmi_wwan_rx_fixup");
+	pr_info("qmap_qmi_wwan_rx_fixup: %d", pQmapDev->qmap_mode);
+	
+	if (pQmapDev->qmap_mode == 0)
+		return qmi_wwan_rx_fixup(dev, skb);
+
+	while (skb->len > sizeof(struct qmap_hdr)) {
+		struct qmap_hdr *qhdr = (struct qmap_hdr *)skb->data;
+		struct net_device *qmap_net;
+		struct sk_buff *qmap_skb;
+#ifdef QUECTEL_BRIDGE_MODE
+		uint bridge_mode = 0;
+		unsigned char *bridge_mac;
+#endif
+		__be16 proto;
+		int pkt_len;
+		u8 offset_id = 0;
+		int err;
+		unsigned len = (be16_to_cpu(qhdr->pkt_len) + sizeof(struct qmap_hdr));
+
+		if (skb->len < len) {
+			dev_info(&dev->net->dev, "drop qmap unknown pkt, len=%d, pkt_len=%d\n", skb->len, be16_to_cpu(qhdr->pkt_len));
+			goto out;
+		}
+
+		debug_pkts++;
+
+		if (qhdr->cd_rsvd_pad & 0x80) {
+			dev_info(&dev->net->dev, "drop qmap command packet %x\n", qhdr->cd_rsvd_pad);
+			goto skip_pkt;
+		}
+
+		offset_id = qhdr->mux_id - QUECTEL_QMAP_MUX_ID;
+		if (offset_id >= pQmapDev->qmap_mode) {
+			dev_info(&dev->net->dev, "drop qmap unknown mux_id %x\n", qhdr->mux_id);
+			goto skip_pkt;
+		}
+
+		qmap_net = pQmapDev->mpQmapNetDev[offset_id];
+
+		if (qmap_net == NULL) {
+			dev_info(&dev->net->dev, "drop qmap unknown mux_id %x\n", qhdr->mux_id);
+			goto skip_pkt;
+		}
+
+		switch (skb->data[sizeof(struct qmap_hdr)] & 0xf0) {
+			case 0x40:
+				proto = htons(ETH_P_IP);
+			break;
+			case 0x60:
+				proto = htons(ETH_P_IPV6);
+			break;
+			default:
+				goto skip_pkt;
+		}
+
+		pkt_len = be16_to_cpu(qhdr->pkt_len) - (qhdr->cd_rsvd_pad&0x3F);
+		qmap_skb = netdev_alloc_skb(qmap_net, ETH_HLEN + pkt_len);
+		if (qmap_skb == NULL) {
+			dev_info(&dev->net->dev, "fail to alloc skb, pkt_len = %d\n", pkt_len);
+			return 0;
+		}
+#if 0
+		pr_info("qmap rx dest fixup to bridge_mac from: %02x:%02x:%02x:%02x:%02x:%02x",
+				eth_hdr(qmap_skb)->h_dest[0],
+				eth_hdr(qmap_skb)->h_dest[1],
+				eth_hdr(qmap_skb)->h_dest[2],
+				eth_hdr(qmap_skb)->h_dest[3],
+				eth_hdr(qmap_skb)->h_dest[4],
+				eth_hdr(qmap_skb)->h_dest[5]);
+#endif
+				
+		skb_reset_mac_header(qmap_skb);
+		memcpy(eth_hdr(qmap_skb)->h_source, default_modem_addr, ETH_ALEN);
+		memcpy(eth_hdr(qmap_skb)->h_dest, qmap_net->dev_addr, ETH_ALEN);
+		eth_hdr(qmap_skb)->h_proto = proto;        
+		memcpy(skb_put(qmap_skb, ETH_HLEN + pkt_len) + ETH_HLEN, skb->data + sizeof(struct qmap_hdr), pkt_len);
+#ifdef QUECTEL_BRIDGE_MODE
+		if (pQmapDev->qmap_mode > 1) {
+			struct qmap_priv *priv = netdev_priv(qmap_net);
+			bridge_mode = priv->bridge_mode;
+			bridge_mac = priv->bridge_mac;
+		}
+		else {
+			bridge_mode = pQmapDev->bridge_mode;
+			bridge_mac = pQmapDev->bridge_mac;
+		}
+		if (bridge_mode) {
+/*			pr_info("qmap rx dest fixup to bridge_mac from: %02x:%02x:%02x:%02x:%02x:%02x",
+				eth_hdr(qmap_skb)->h_dest[0],
+				eth_hdr(qmap_skb)->h_dest[1],
+				eth_hdr(qmap_skb)->h_dest[2],
+				eth_hdr(qmap_skb)->h_dest[3],
+				eth_hdr(qmap_skb)->h_dest[4],
+				eth_hdr(qmap_skb)->h_dest[5]			
+			); */
+			memcpy(eth_hdr(qmap_skb)->h_dest, bridge_mac, ETH_ALEN);
+		}
+#endif
+
+		if (pQmapDev->qmap_mode > 1) {
+			qmap_skb->protocol = eth_type_trans (qmap_skb, qmap_net);
+			memset(qmap_skb->cb, 0, sizeof(struct skb_data));
+			err = netif_rx(qmap_skb);
+			if (err == NET_RX_SUCCESS) {
+				qmap_net->stats.rx_packets++;
+				qmap_net->stats.rx_bytes += qmap_skb->len;
+			} else {
+				qmap_net->stats.rx_errors++;
+			}
+		}
+		else {
+			usbnet_skb_return(dev, qmap_skb);
+		}
+
+		skip_pkt:
+		skb_pull(skb, len);
+	}
+
+out:
+	if (update_len > debug_len) {
+		debug_len = update_len;
+//		dev_info(&dev->net->dev, "rx_pkts=%d, rx_len=%d\n", debug_pkts, debug_len);
+	}
+	
+    return 0;
+}
+#endif
+
+///* default ethernet address used by the modem */
+//static const u8 default_modem_addr[ETH_ALEN] = {0x02, 0x50, 0xf3};
+
+static const u8 buggy_fw_addr[ETH_ALEN] = {0x00, 0xa0, 0xc6, 0x00, 0x00, 0x00};
+
+
 /* very simplistic detection of IPv4 or IPv6 headers */
 static bool possibly_iphdr(const char *data)
 {
@@ -629,7 +1511,7 @@
 {
 	int ret;
 	struct sockaddr *addr = p;
-
+	pr_info("qmi_wwan_mac_addr");
 	ret = eth_prepare_mac_addr_change(dev, p);
 	if (ret < 0)
 		return ret;
@@ -745,7 +1627,7 @@
 
 static int qmi_wwan_bind(struct usbnet *dev, struct usb_interface *intf)
 {
-	int status;
+	int status = -1;
 	u8 *buf = intf->cur_altsetting->extra;
 	int len = intf->cur_altsetting->extralen;
 	struct usb_interface_descriptor *desc = &intf->cur_altsetting->desc;
@@ -757,7 +1639,7 @@
 
 	BUILD_BUG_ON((sizeof(((struct usbnet *)0)->data) <
 		      sizeof(struct qmi_wwan_state)));
-
+    dev_info(&intf->dev, "qmi_wwan_bind");
 	/* set up initial state */
 	info->control = intf;
 	info->data = intf;
@@ -825,21 +1707,117 @@
 		qmi_wwan_manage_power(dev, 1);
 		qmi_wwan_change_dtr(dev, true);
 	}
+	
+	if (dev->driver_info->data & QMI_WWAN_QUIRK_RAW) {
+       qmi_flags |= QMI_WWAN_FLAG_RAWIP;
+    }
 
 	/* Never use the same address on both ends of the link, even if the
 	 * buggy firmware told us to. Or, if device is assigned the well-known
 	 * buggy firmware MAC address, replace it with a random address,
 	 */
+
 	if (ether_addr_equal(dev->net->dev_addr, default_modem_addr) ||
 	    ether_addr_equal(dev->net->dev_addr, buggy_fw_addr))
 		eth_hw_addr_random(dev->net);
-
+    pr_info("pr_info: dev->net->dev_addr %x", dev->net->dev_addr);
 	/* make MAC addr easily distinguishable from an IP header */
 	if (possibly_iphdr(dev->net->dev_addr)) {
 		dev->net->dev_addr[0] |= 0x02;	/* set local assignment bit */
 		dev->net->dev_addr[0] &= 0xbf;	/* clear "IP" bit */
+		pr_info("pr_info: dev->net->dev_addr %x", dev->net->dev_addr);
 	}
 	dev->net->netdev_ops = &qmi_wwan_netdev_ops;
+    pr_info("pr_info: before dev->driver_info->flags & FLAG_NOARP");
+	pr_info("pr_info: dev->driver_info->flags-%d & FLAG_NOARP-%d", dev->driver_info->flags, FLAG_NOARP);
+ #if 1 //Added by Quectel
+	if (dev->driver_info->flags & FLAG_NOARP) {		
+		//dev_info(&intf->dev, "Quectel EC25&EC21&EG91&EG95&EG06&EP06&EM06&EG12&EP12&EM12&EG16&EG18&BG96&AG35 work on RawIP mode\n");
+		pr_info("pr_info: dev->driver_info->flags & FLAG_NOARP");
+#if defined(QUECTEL_WWAN_QMAP)
+		dev_info(&intf->dev, "AWC combined wwan bridge driver (mode = %d) - with QMAP (mode = %d)", 
+                 bridge_mode,
+                 qmap_mode);
+#else
+		dev_info(&intf->dev, "AWC Combined wwan bridge mode driver - no QMAP");
+#endif	
+		
+		dev->net->flags |= IFF_NOARP;
+		usb_control_msg(
+			interface_to_usbdev(intf),
+			usb_sndctrlpipe(interface_to_usbdev(intf), 0),
+			0x22, //USB_CDC_REQ_SET_CONTROL_LINE_STATE
+			0x21, //USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE
+			1, //active CDC DTR
+			intf->cur_altsetting->desc.bInterfaceNumber,
+			NULL, 0, 100);
+	}
+
+	// to avoid module report mtu 1460, but rx 1500 bytes IP packets, and cause the customer's system crash
+	// next setting can make usbnet.c:usbnet_change_mtu() do not modify rx_urb_size according to hard MTU
+	dev->rx_urb_size = ETH_DATA_LEN + ETH_HLEN + 6;
+	//dev_info(&intf->dev, "rx_urb_size: %d", dev->rx_urb_size);   
+    
+#if defined(QUECTEL_WWAN_QMAP)
+	if (qmap_mode > QUECTEL_WWAN_QMAP)
+		qmap_mode = QUECTEL_WWAN_QMAP;
+
+	if (!status)
+	{
+		sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)kzalloc(sizeof(sQmiWwanQmap), GFP_KERNEL);
+
+		if (pQmapDev == NULL)
+			return -ENODEV;
+
+#ifdef QUECTEL_BRIDGE_MODE
+		pQmapDev->bridge_mode = bridge_mode;
+#endif
+		pQmapDev->mpNetDev = dev;
+		pQmapDev->link_state = 1;
+		
+		if (dev->driver_info->flags & FLAG_NOARP)
+		{
+			int idProduct = le16_to_cpu(dev->udev->descriptor.idProduct);
+			int lte_a = (idProduct == 0x0306 || idProduct == 0x0512 || idProduct == 0x0620 || idProduct == 0x0800 || idProduct == 0x1070);
+
+			pQmapDev->qmap_mode = qmap_mode;
+			if (lte_a || dev->udev->speed == USB_SPEED_SUPER) {
+#if 0
+				if (pQmapDev->qmap_mode == 0) {
+					pQmapDev->qmap_mode = 1; //force use QMAP
+					if(qmap_mode == 0)
+						qmap_mode = 1; //old quectel-CM only check sys/module/wwan0/parameters/qmap_mode
+				}
+#endif
+			}
+
+			if (pQmapDev->qmap_mode) {
+				if (idProduct == 0x0121 || idProduct == 0x0125 || idProduct == 0x0435) //MDM9x07
+					dev->rx_urb_size = 4*1024;
+				else if (lte_a || dev->udev->speed == USB_SPEED_SUPER)
+					dev->rx_urb_size = 32*1024;
+				else
+					dev->rx_urb_size = 32*1024;
+
+				// For these modules, if a packet is sent before qmi_start_network, it can cause a crash
+				if (lte_a || dev->udev->speed == USB_SPEED_SUPER)
+					pQmapDev->link_state = 0;
+			}
+		}
+
+		info->unused = (unsigned long)pQmapDev;		
+	//	dev->net->sysfs_groups[0] = &qmi_wwan_sysfs_attr_group;
+
+		dev_info(&intf->dev, "rx_urb_size = %zd qmap_mode = %d bridge_mode = %d\n", 
+                 dev->rx_urb_size, 
+                 pQmapDev->qmap_mode,
+                 pQmapDev->bridge_mode
+                );
+	}
+#endif
+#endif     
+    
+    
 	dev->net->sysfs_groups[0] = &qmi_wwan_sysfs_attr_group;
 err:
 	return status;
@@ -926,7 +1904,7 @@
 }
 
 static const struct driver_info	qmi_wwan_info = {
-	.description	= "WWAN/QMI device",
+	.description	= "WWAN/QMI device (standard)",
 	.flags		= FLAG_WWAN | FLAG_SEND_ZLP,
 	.bind		= qmi_wwan_bind,
 	.unbind		= qmi_wwan_unbind,
@@ -934,12 +1912,35 @@
 	.rx_fixup       = qmi_wwan_rx_fixup,
 };
 
+static const struct driver_info qmi_wwan_raw_ip_info = {
+	.description	= "WWAN/QMI device (raw)",
+	.flags		= FLAG_WWAN | FLAG_RX_ASSEMBLE | FLAG_NOARP | FLAG_SEND_ZLP,
+	.bind		= qmi_wwan_bind,
+	.unbind		= qmi_wwan_unbind,
+	.manage_power	= qmi_wwan_manage_power,
+#if defined(QUECTEL_WWAN_QMAP)
+	.tx_fixup       = qmap_qmi_wwan_tx_fixup,
+	.rx_fixup       = qmap_qmi_wwan_rx_fixup,
+#else
+	//.tx_fixup       = qmi_wwan_tx_fixup,
+	.rx_fixup       = qmi_wwan_rx_fixup,
+#endif
+    .data           = QMI_WWAN_QUIRK_RAW,
+};
+
 static const struct driver_info	qmi_wwan_info_quirk_dtr = {
-	.description	= "WWAN/QMI device",
-	.flags		= FLAG_WWAN | FLAG_SEND_ZLP,
+	.description	= "WWAN/QMI device (quirk)",
+	.flags		= FLAG_WWAN | FLAG_RX_ASSEMBLE | FLAG_NOARP | FLAG_SEND_ZLP,
 	.bind		= qmi_wwan_bind,
 	.unbind		= qmi_wwan_unbind,
 	.manage_power	= qmi_wwan_manage_power,
+#if defined(QUECTEL_WWAN_QMAP)
+	.tx_fixup       = qmap_qmi_wwan_tx_fixup,
+	.rx_fixup       = qmap_qmi_wwan_rx_fixup,
+#else
+	//.tx_fixup       = qmi_wwan_tx_fixup,
+	.rx_fixup       = qmi_wwan_rx_fixup,
+#endif
 	.rx_fixup       = qmi_wwan_rx_fixup,
 	.data           = QMI_WWAN_QUIRK_DTR,
 };
@@ -951,6 +1952,11 @@
 	USB_DEVICE_INTERFACE_NUMBER(vend, prod, num), \
 	.driver_info = (unsigned long)&qmi_wwan_info
 
+#define QMI_FIXED_RAWIP_INTF(vend, prod, num) \
+	USB_DEVICE_INTERFACE_NUMBER(vend, prod, num), \
+	.driver_info = (unsigned long)&qmi_wwan_raw_ip_info	
+	
+
 /* devices requiring "set DTR" quirk */
 #define QMI_QUIRK_SET_DTR(vend, prod, num) \
 	USB_DEVICE_INTERFACE_NUMBER(vend, prod, num), \
@@ -978,6 +1984,7 @@
 	.driver_info = (unsigned long)&qmi_wwan_info_quirk_dtr
 
 static const struct usb_device_id products[] = {
+#if 0
 	/* 1. CDC ECM like devices match on the control interface */
 	{	/* Huawei E392, E398 and possibly others sharing both device id and more... */
 		USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, USB_CLASS_VENDOR_SPEC, 1, 9),
@@ -1492,6 +2499,37 @@
 	{QMI_GOBI_DEVICE(0x12d1, 0x14f1)},	/* Sony Gobi 3000 Composite */
 	{QMI_GOBI_DEVICE(0x1410, 0xa021)},	/* Foxconn Gobi 3000 Modem device (Novatel E396) */
 
+#else
+   //Added by Quectel
+	{ QMI_FIXED_INTF(0x05C6, 0x9003, 4) },  /* Quectel UC20 */
+	{ QMI_FIXED_INTF(0x05C6, 0x9215, 4) },  /* Quectel EC20 (MDM9215) */
+	{ QMI_FIXED_RAWIP_INTF(0x2C7C, 0x0125, 4) },  /* Quectel EC20 (MDM9X07)/EC25/EG25 */
+	{ QMI_FIXED_RAWIP_INTF(0x2C7C, 0x0121, 4) },  /* Quectel EC21 */
+	{ QMI_FIXED_RAWIP_INTF(0x2C7C, 0x0191, 4) },  /* Quectel EG91 */
+	{ QMI_FIXED_RAWIP_INTF(0x2C7C, 0x0195, 4) },  /* Quectel EG95 */
+	{ QMI_FIXED_RAWIP_INTF(0x2C7C, 0x0306, 4) },  /* Quectel EG06/EP06/EM06 */
+	{ QMI_FIXED_RAWIP_INTF(0x2C7C, 0x0512, 4) },  /* Quectel EG12/EP12/EM12/EG16/EG18 */
+	{ QMI_FIXED_RAWIP_INTF(0x2C7C, 0x0296, 4) },  /* Quectel BG96 */
+	{ QMI_FIXED_RAWIP_INTF(0x2C7C, 0x0435, 4) },  /* Quectel AG35 */
+	{ QMI_FIXED_RAWIP_INTF(0x2C7C, 0x0620, 4) },  /* Quectel EG20 */
+	{ QMI_FIXED_RAWIP_INTF(0x2C7C, 0x0800, 4) },  /* Quectel RG500 */ 
+   //Added by Telit
+	{QMI_QUIRK_SET_DTR(0x1bc7, 0x1031, 3)}, /* Telit LE910C1-EUX */
+	{QMI_QUIRK_SET_DTR(0x1bc7, 0x1040, 2)},	/* Telit LE922A */
+	{QMI_QUIRK_SET_DTR(0x1bc7, 0x1050, 2)},	/* Telit FN980 */
+	{QMI_QUIRK_SET_DTR(0x1bc7, 0x1060, 2)},	/* Telit LN920 */
+	{QMI_QUIRK_SET_DTR(0x1bc7, 0x1070, 2)},	/* Telit FN990 */
+	{QMI_QUIRK_SET_DTR(0x1bc7, 0x1080, 2)}, /* Telit FE990 */
+	{QMI_FIXED_INTF(0x1bc7, 0x1100, 3)},	/* Telit ME910 */
+	{QMI_FIXED_INTF(0x1bc7, 0x1101, 3)},	/* Telit ME910 dual modem */
+	{QMI_FIXED_INTF(0x1bc7, 0x1200, 5)},	/* Telit LE920 */
+	{QMI_QUIRK_SET_DTR(0x1bc7, 0x1201, 2)},	/* Telit LE920, LE920A4 */
+	{QMI_QUIRK_SET_DTR(0x1bc7, 0x1230, 2)},	/* Telit LE910Cx */
+	{QMI_QUIRK_SET_DTR(0x1bc7, 0x1260, 2)},	/* Telit LE910Cx */
+	{QMI_QUIRK_SET_DTR(0x1bc7, 0x1261, 2)},	/* Telit LE910Cx */
+	{QMI_QUIRK_SET_DTR(0x1bc7, 0x1900, 1)},	/* Telit LN940 series */
+#endif
+
 	{ }					/* END */
 };
 MODULE_DEVICE_TABLE(usb, products);
@@ -1514,7 +2552,8 @@
 {
 	struct usb_device_id *id = (struct usb_device_id *)prod;
 	struct usb_interface_descriptor *desc = &intf->cur_altsetting->desc;
-
+	
+	pr_info("pr_info: qmi_wwan_probe");
 	/* Workaround to enable dynamic IDs.  This disables usbnet
 	 * blacklisting functionality.  Which, if required, can be
 	 * reimplemented here by using a magic "blacklist" value
@@ -1549,12 +2588,66 @@
 	 * different. Ignore the current interface if the number of endpoints
 	 * equals the number for the diag interface (two).
 	 */
-	if (desc->bNumEndpoints == 2)
+
+	if (desc->bNumEndpoints == 2) {
 		return -ENODEV;
+	}
 
 	return usbnet_probe(intf, id);
 }
 
+#if defined(QUECTEL_WWAN_QMAP)
+static int qmap_qmi_wwan_probe(struct usb_interface *intf,
+			  const struct usb_device_id *prod)
+{
+	int status = qmi_wwan_probe(intf, prod);
+    pr_info("pr_info: qmap_qmi_wwan_probe");
+	dev_info(&intf->dev, "qmap_qmi_wwan_probe");	
+	    
+	if (!status) {
+		struct usbnet *dev = usb_get_intfdata(intf);
+		struct qmi_wwan_state *info = (void *)&dev->data;		
+		sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+		unsigned i;
+
+		if (pQmapDev) {
+			if (pQmapDev->qmap_mode == 1) {
+				pQmapDev->mpQmapNetDev[0] = dev->net;
+			}
+			else if (pQmapDev->qmap_mode > 1) {
+				for (i = 0; i < pQmapDev->qmap_mode; i++) {
+					qmap_register_device(pQmapDev, i);
+				}
+			}
+		}
+	}
+
+	return status;
+}
+
+static void qmap_qmi_wwan_disconnect(struct usb_interface *intf)
+{
+	struct usbnet *dev = usb_get_intfdata(intf);
+	struct qmi_wwan_state *info = (void *)&dev->data;
+	sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+
+	if (pQmapDev) {
+		if (pQmapDev->qmap_mode > 1) {
+			unsigned i;
+
+			for (i = 0; i < pQmapDev->qmap_mode; i++) {
+				qmap_unregister_device(pQmapDev, i);
+			}	
+		}
+		
+		kfree(pQmapDev);
+	}
+
+	usbnet_disconnect(intf);
+}
+
+#else
+
 static void qmi_wwan_disconnect(struct usb_interface *intf)
 {
 	struct usbnet *dev = usb_get_intfdata(intf);
@@ -1567,7 +2660,7 @@
 	if (!dev)
 		return;
 	info = (void *)&dev->data;
-	if (info->flags & QMI_WWAN_FLAG_MUX) {
+	if (/*info->flags*/ qmi_flags & QMI_WWAN_FLAG_MUX) {
 		if (!rtnl_trylock()) {
 			restart_syscall();
 			return;
@@ -1578,16 +2671,23 @@
 		rcu_read_unlock();
 		unregister_netdevice_many(&list);
 		rtnl_unlock();
-		info->flags &= ~QMI_WWAN_FLAG_MUX;
+		/*info->flags*/ qmi_flags &= ~QMI_WWAN_FLAG_MUX;
 	}
 	usbnet_disconnect(intf);
 }
 
+#endif
+
 static struct usb_driver qmi_wwan_driver = {
 	.name		      = "qmi_wwan",
 	.id_table	      = products,
-	.probe		      = qmi_wwan_probe,
+#if defined(QUECTEL_WWAN_QMAP)
+	.probe		      = qmap_qmi_wwan_probe,
+	.disconnect	      = qmap_qmi_wwan_disconnect,
+#else 
+	.probe		      = qmi_wwan_probe,    
 	.disconnect	      = qmi_wwan_disconnect,
+#endif
 	.suspend	      = qmi_wwan_suspend,
 	.resume		      =	qmi_wwan_resume,
 	.reset_resume         = qmi_wwan_resume,
